@startuml Chess_Class_Diagram

' Styling
skinparam classAttributeIconSize 0
skinparam class {
    BackgroundColor LightYellow
    BorderColor Black
    ArrowColor Black
}

' ==================== MAIN & APP ====================
class Main {
    + main()
}

class ChessApp {
    - screen_manager: ScreenManager
    - controller: GameController
    + build(): ScreenManager
    + on_start()
}

' ==================== CONTROLLER ====================
class GameController {
    - board: Board
    - chess_logic: ChessLogic
    - timer: ChessTimer
    - db: DatabaseManager
    - current_turn: str
    - game_is_over: bool
    - current_game_id: int
    - white_player: tuple
    - black_player: tuple
    - selected_piece: Piece
    - valid_moves: list[Move]
    - move_history: list[Move]
    - last_move: Move
    - board_widget: ChessBoard
    - game_screen: GameScreen
    __
    + start_new_game()
    + handle_square_click(row: int, col: int)
    + make_move(move: Move)
    + complete_move(move: Move)
    + game_over(result_type: str, winner: str)
    + request_draw()
    + accept_draw()
    + get_replay_position(move_index: int): np.ndarray
    - _select_piece(row: int, col: int)
    - _move_selected_piece(row: int, col: int)
    - _serialize_board(): str
    - _deserialize_board(board_json: str): np.ndarray
    - _save_game_result(winner: str, result_type: str)
}

' ==================== BOARD & LOGIC ====================
class Board {
    + squares: np.ndarray[8,8]
    + white_king: King
    + black_king: King
    __
    + setup_startpos()
    + make_move(move: Move)
    + is_square_attacked_by(pos: tuple, color: str): bool
}

class ChessLogic {
    - board: Board
    __
    + calculate_all_moves(): dict
    + all_legal_moves(last_move: Move, current_turn: str): list[Move]
    + is_in_check(color: str): bool
    + is_checkmate(color: str): bool
    + is_stalemate(color: str): bool
    + can_castle(color: str, side: str): bool
    + filter_moves_for_check(moves: list[Move], color: str): list[Move]
}

class Move {
    + from_pos: tuple
    + to_pos: tuple
    + captured_piece: Piece
    + is_castling: bool
    + castling_rook_move: tuple
    + is_en_passant: bool
    + en_passant_captured: tuple
    + is_promotion: bool
    + promotion_piece: Piece
}

' ==================== PIECES ====================
abstract class Piece {
    # color: str
    # position: tuple
    # notation: str
    # pawn: bool
    __
    + {abstract} get_legal_moves(board: Board): list[Move]
    + get_image_path(): str
    + move_to(next_position: tuple)
    # {static} _is_valid_square(row: int, col: int): bool
}

class King {
    + moved: bool
    + checkmate: bool
    __
    + get_legal_moves(board: Board): list[Move]
}

class Queen {
    + get_legal_moves(board: Board): list[Move]
}

class Rook {
    + moved: bool
    __
    + get_legal_moves(board: Board): list[Move]
}

class Bishop {
    + get_legal_moves(board: Board): list[Move]
}

class Knight {
    + get_legal_moves(board: Board): list[Move]
}

class Pawn {
    + get_legal_moves(board: Board): list[Move]
}

' ==================== DATABASE ====================
class DatabaseManager {
    - db_path: str
    - conn: sqlite3.Connection
    __
    + create_player(username: str): int
    + get_player(player_id: int): dict
    + get_player_by_username(username: str): dict
    + update_player_stats(player_id: int, points: int, won: bool, lost: bool)
    + create_game(white_id: int, black_id: int, game_type: str, time: int): int
    + finish_game(game_id: int, winner: str, result_type: str)
    + add_board(game_id: int, board_number: int, board_JSON: str, notation: str, white_time: str, black_time: str)
    + get_game(game_id: int): dict
    + get_game_boards(game_id: int): list[dict]
    + get_leaderboard(limit: int): list[dict]
    + get_all_games(limit: int): list[dict]
    - _create_tables()
}

' ==================== TIMER ====================
class ChessTimer {
    - white_time: int
    - black_time: int
    - active_player: str
    - stopwatch_mode: bool
    - on_time_up_callback: callable
    - timer_event: ClockEvent
    __
    + start()
    + stop()
    + switch_player()
    + reset()
    - _tick(dt: float)
}

' ==================== UI - SCREENS ====================
abstract class Screen {
    + name: str
}

class StartMenuScreen {
    - controller: GameController
    __
    + start_game(instance)
    + open_stats(instance)
    + quit_app(instance)
}

class PlayerSelectionScreen {
    - controller: GameController
    - white_input: TextInput
    - black_input: TextInput
    - timer_checkbox: CheckBox
    - time_input: TextInput
    __
    + start_game(instance)
    + toggle_timer_input(checkbox, value)
}

class GameScreen {
    - controller: GameController
    - board: ChessBoard
    - info_label: Label
    - white_timer_label: Label
    - black_timer_label: Label
    - history_container: BoxLayout
    __
    + set_players(white, black, use_timer, time)
    + update_turn_info(current_turn: str)
    + update_move_history(moves: list[Move])
    + update_timer_display(white_time: int, black_time: int, active: str)
    + show_promotion_popup(color: str, callback)
    + show_game_over_popup(result_type: str, winner: str, controller)
    + request_draw(instance)
    + show_draw_confirm_popup()
}

class StatsMenuScreen {
    - controller: GameController
    __
    + show_leaderboard(instance)
    + show_game_history(instance)
}

class LeaderboardScreen {
    - controller: GameController
    - leaderboard_container: BoxLayout
    __
    + on_pre_enter()
    + load_leaderboard()
}

class GameHistoryScreen {
    - controller: GameController
    - games_container: BoxLayout
    __
    + on_pre_enter()
    + load_game_history()
    + view_game(game: dict)
    - _rgb_to_hex(rgb_tuple: tuple): str
}

class GameReplayScreen {
    - controller: GameController
    - board: ChessBoard
    - current_move_index: int
    - boards: list[dict]
    - game_data: dict
    - history_container: BoxLayout
    __
    + load_game(game_id: int)
    + show_position()
    + update_history_display()
    + go_to_first(instance)
    + prev_move(instance)
    + next_move(instance)
    + go_to_last(instance)
}

class PauseMenuScreen {
    - controller: GameController
    __
    + resume_game(instance)
    + restart_game(instance)
    + go_to_menu(instance)
}

' ==================== UI - WIDGETS ====================
class ChessBoard {
    - board_array: np.ndarray
    - controller: GameController
    - squares: list[ChessSquare]
    __
    + update_board(board_array: np.ndarray, checkmate_info)
    + highlight_moves(moves: list[Move])
    + clear_highlights()
    + set_controller(controller: GameController)
}

class ChessSquare {
    - row: int
    - col: int
    - color: tuple
    - piece_image: Image
    __
    + set_piece(image_path: str)
    + clear_piece()
    + highlight()
    + unhighlight()
    + on_touch_down(touch)
}

' ==================== RELATIONSHIPS ====================

' Main & App
Main --> ChessApp : creates

' App & Controller
ChessApp --> GameController : creates
ChessApp --> Screen : manages

' Controller Relationships
GameController --> Board : uses
GameController --> ChessLogic : uses
GameController --> ChessTimer : uses
GameController --> DatabaseManager : uses
GameController --> Move : creates
GameController --> ChessBoard : updates
GameController --> GameScreen : updates

' Board & Pieces
Board --> Piece : contains
Board --> King : tracks
Board --> Move : uses

' Logic & Board
ChessLogic --> Board : analyzes
ChessLogic --> Move : validates

' Piece Hierarchy
Piece <|-- King
Piece <|-- Queen
Piece <|-- Rook
Piece <|-- Bishop
Piece <|-- Knight
Piece <|-- Pawn

' Screen Hierarchy
Screen <|-- StartMenuScreen
Screen <|-- PlayerSelectionScreen
Screen <|-- GameScreen
Screen <|-- StatsMenuScreen
Screen <|-- LeaderboardScreen
Screen <|-- GameHistoryScreen
Screen <|-- GameReplayScreen
Screen <|-- PauseMenuScreen

' Screen & Controller
StartMenuScreen --> GameController : uses
PlayerSelectionScreen --> GameController : uses
GameScreen --> GameController : uses
GameScreen --> ChessBoard : contains
StatsMenuScreen --> GameController : uses
LeaderboardScreen --> GameController : uses
GameHistoryScreen --> GameController : uses
GameReplayScreen --> GameController : uses
PauseMenuScreen --> GameController : uses

' Widget Relationships
ChessBoard --> ChessSquare : contains
ChessSquare --> GameController : notifies
GameScreen --> ChessBoard : displays

' Database
DatabaseManager --> "SQLite" : uses

' Notes
note right of GameController
    Central coordinator:
    - Manages game state
    - Controls game flow
    - Bridges UI and Logic
end note

note right of Board
    Represents 8x8 grid
    using NumPy array
end note

note right of ChessLogic
    Validates moves and
    checks game rules
end note

note bottom of Piece
    Abstract base class
    for all chess pieces
end note

@enduml
